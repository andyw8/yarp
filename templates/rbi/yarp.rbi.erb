# frozen_string_literal: true
=begin
This file is generated by the bin/template script and should not be
modified manually. See templates/lib/yarp/sorbet.rb.erb
if you are looking to modify the template
=end

  # Represents the use of the `alias` keyword.
  #
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasNode < Node
    sig { returns(YARP::Node) }
    attr_reader :new_name

    sig { returns(YARP::Node) }
    attr_reader :old_name

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(new_name: YARP::Node, old_name: YARP::Node, keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(new_name, old_name, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents an alternation pattern in pattern matching.
  #
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    sig { returns(YARP::Node) }
    attr_reader :left

    sig { returns(YARP::Node) }
    attr_reader :right

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(left: YARP::Node, right: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `&&` operator or the `and` keyword.
  #
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    sig { returns(YARP::Node) }
    attr_reader :left

    sig { returns(YARP::Node) }
    attr_reader :right

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(left: YARP::Node, right: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents a set of arguments to a method or a keyword.
  #
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :arguments

    sig do
      params(arguments: T::Array[YARP::Node], location: YARP::Location).void
    end
    def initialize(arguments, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents an array literal. This can be a regular array using brackets or
  # a special array using % like %w or %i.
  #
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :elements

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(elements: T::Array[YARP::Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(elements, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents an array pattern in pattern matching.
  #
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  #
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  #
  #     foo in *1
  #     ^^^^^^^^^
  #
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  #
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :constant

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :requireds

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :rest

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :posts

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(constant: T.nilable(YARP::Node), requireds: T::Array[YARP::Node], rest: T.nilable(YARP::Node), posts: T::Array[YARP::Node], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents a hash key/value pair.
  #
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    sig { returns(YARP::Node) }
    attr_reader :key

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig do
      params(key: YARP::Node, value: T.nilable(YARP::Node), operator_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(key, value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents a splat in a hash literal.
  #
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(value: T.nilable(YARP::Node), operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents reading a reference to a field in the previous match.
  #
  #     $'
  #     ^^
  class BackReferenceReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a begin statement.
  #
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :begin_keyword_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :rescue_clause

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :else_clause

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :ensure_clause

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig do
      params(begin_keyword_loc: T.nilable(Location), statements: T.nilable(YARP::Node), rescue_clause: T.nilable(YARP::Node), else_clause: T.nilable(YARP::Node), ensure_clause: T.nilable(YARP::Node), end_keyword_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def begin_keyword; end

    sig { returns(T.nilable(String))}
    def end_keyword; end
  end
  # Represents block method arguments.
  #
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :expression

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(expression: T.nilable(YARP::Node), operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(expression, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents a block of ruby code.
  #
  # [1, 2, 3].each { |i| puts x }
  #                ^^^^^^^^^^^^^^
  class BlockNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :parameters

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(locals: T::Array[YARP::Symbol], parameters: T.nilable(YARP::Node), statements: T.nilable(YARP::Node), opening_loc: YARP::Location, closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(locals, parameters, statements, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a block parameter to a method, block, or lambda definition.
  #
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(name_loc: T.nilable(Location), operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents a block's parameters declaration.
  #
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :parameters

    sig { returns(T::Array[YARP::Location]) }
    attr_reader :locals

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(parameters: T.nilable(YARP::Node), locals: T::Array[YARP::Location], opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(parameters, locals, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents the use of the `break` keyword.
  #
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(arguments: T.nilable(YARP::Node), keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(arguments, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents a method call, in all of the various forms that can take.
  #
  #     foo
  #     ^^^
  #
  #     foo()
  #     ^^^^^
  #
  #     +foo
  #     ^^^^
  #
  #     foo + bar
  #     ^^^^^^^^^
  #
  #     foo.bar
  #     ^^^^^^^
  #
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :message_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :block

    sig { returns(Integer) }
    attr_reader :flags

    sig { returns(String) }
    attr_reader :name

    sig do
      params(receiver: T.nilable(YARP::Node), operator_loc: T.nilable(Location), message_loc: T.nilable(Location), opening_loc: T.nilable(Location), arguments: T.nilable(YARP::Node), closing_loc: T.nilable(Location), block: T.nilable(YARP::Node), flags: Integer, name: String, location: YARP::Location).void
    end
    def initialize(receiver, operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def operator; end

    sig { returns(T.nilable(String))}
    def message; end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents the use of the `&&=` operator on a call.
  #
  #     foo.bar &&= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOperatorAndWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(target: YARP::Node, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator on a call.
  #
  #     foo.bar ||= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOperatorOrWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(target: YARP::Node, value: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(target, value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of an assignment operator on a call.
  #
  #     foo.bar += baz
  #     ^^^^^^^^^^^^^^
  class CallOperatorWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator_id

    sig do
      params(target: YARP::Node, operator_loc: YARP::Location, value: YARP::Node, operator_id: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, operator_id, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a local variable in pattern matching.
  #
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(value: YARP::Node, target: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(value, target, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of a case statement.
  #
  # case true
  # ^^^^^^^^^
  # when false
  # end
  class CaseNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :predicate

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :conditions

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :consequent

    sig { returns(YARP::Location) }
    attr_reader :case_keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(predicate: T.nilable(YARP::Node), conditions: T::Array[YARP::Node], consequent: T.nilable(YARP::Node), case_keyword_loc: YARP::Location, end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def case_keyword; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents a class declaration involving the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Location) }
    attr_reader :class_keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :constant_path

    sig { returns(T.nilable(Location)) }
    attr_reader :inheritance_operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :superclass

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(locals: T::Array[YARP::Symbol], class_keyword_loc: YARP::Location, constant_path: YARP::Node, inheritance_operator_loc: T.nilable(Location), superclass: T.nilable(YARP::Node), statements: T.nilable(YARP::Node), end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, statements, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def class_keyword; end

    sig { returns(T.nilable(String))}
    def inheritance_operator; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents the use of the `&&=` operator for assignment to a class variable.
  #
  #     @@target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ClassVariableOperatorAndWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to a class variable.
  #
  #     @@target ||= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorOrWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a class variable using an operator that isn't `=`.
  #
  #     @@target += value
  #     ^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, operator: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end
  end
  # Represents referencing a class variable.
  #
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to a class variable.
  #
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig do
      params(name_loc: YARP::Location, value: T.nilable(YARP::Node), operator_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(name_loc, value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents the use of the `&&=` operator for assignment to a constant.
  #
  #     Target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOperatorAndWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to a constant.
  #
  #     Target ||= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOperatorOrWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a constant using an operator that isn't `=`.
  #
  #     Target += value
  #     ^^^^^^^^^^^^^^^
  class ConstantOperatorWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, operator: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end
  end
  # Represents accessing a constant through a path of `::` operators.
  #
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :parent

    sig { returns(YARP::Node) }
    attr_reader :child

    sig { returns(YARP::Location) }
    attr_reader :delimiter_loc

    sig do
      params(parent: T.nilable(YARP::Node), child: YARP::Node, delimiter_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(parent, child, delimiter_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def delimiter; end
  end
  # Represents the use of the `&&=` operator for assignment to a constant path.
  #
  #     Parent::Child &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorAndWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(target: YARP::Node, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to a constant path.
  #
  #     Parent::Child ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorOrWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(target: YARP::Node, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a constant path using an operator that isn't `=`.
  #
  #     Parent::Child += value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator

    sig do
      params(target: YARP::Node, operator_loc: YARP::Location, value: YARP::Node, operator: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, operator, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to a constant path.
  #
  #     ::Foo = 1
  #     ^^^^^^^^^
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  #
  #     ::Foo::Bar = 1
  #     ^^^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    sig { returns(YARP::Node) }
    attr_reader :target

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig do
      params(target: YARP::Node, operator_loc: T.nilable(Location), value: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(target, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents referencing a constant.
  #
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to a constant.
  #
  #     Foo = 1
  #     ^^^^^^^
  class ConstantWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig do
      params(name_loc: YARP::Location, value: T.nilable(YARP::Node), operator_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(name_loc, value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents a method definition.
  #
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :receiver

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :parameters

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Location) }
    attr_reader :def_keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :equal_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig do
      params(name_loc: YARP::Location, receiver: T.nilable(YARP::Node), parameters: T.nilable(YARP::Node), statements: T.nilable(YARP::Node), locals: T::Array[YARP::Symbol], def_keyword_loc: YARP::Location, operator_loc: T.nilable(Location), lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), equal_loc: T.nilable(Location), end_keyword_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(name_loc, receiver, parameters, statements, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def def_keyword; end

    sig { returns(T.nilable(String))}
    def operator; end

    sig { returns(T.nilable(String))}
    def lparen; end

    sig { returns(T.nilable(String))}
    def rparen; end

    sig { returns(T.nilable(String))}
    def equal; end

    sig { returns(T.nilable(String))}
    def end_keyword; end
  end
  # Represents the use of the `defined?` keyword.
  #
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(lparen_loc: T.nilable(Location), value: YARP::Node, rparen_loc: T.nilable(Location), keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def lparen; end

    sig { returns(T.nilable(String))}
    def rparen; end

    sig { returns(String) }
    def keyword; end
  end
  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  #
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    sig { returns(YARP::Location) }
    attr_reader :else_keyword_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig do
      params(else_keyword_loc: YARP::Location, statements: T.nilable(YARP::Node), end_keyword_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def else_keyword; end

    sig { returns(T.nilable(String))}
    def end_keyword; end
  end
  # Represents an interpolated set of statements.
  #
  #     "foo #{bar}"
  #          ^^^^^^
  class EmbeddedStatementsNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(opening_loc: YARP::Location, statements: T.nilable(YARP::Node), closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(opening_loc, statements, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents an interpolated variable.
  #
  #     "foo #@bar"
  #          ^^^^^
  class EmbeddedVariableNode < Node
    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :variable

    sig do
      params(operator_loc: YARP::Location, variable: YARP::Node, location: YARP::Location).void
    end
    def initialize(operator_loc, variable, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents an `ensure` clause in a `begin` statement.
  #
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    sig { returns(YARP::Location) }
    attr_reader :ensure_keyword_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(ensure_keyword_loc: YARP::Location, statements: T.nilable(YARP::Node), end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def ensure_keyword; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents the use of the literal `false` keyword.
  #
  #     false
  #     ^^^^^
  class FalseNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a find pattern in pattern matching.
  #
  #     foo in *bar, baz, *qux
  #     ^^^^^^^^^^^^^^^^^^^^^^
  #
  #     foo in [*bar, baz, *qux]
  #     ^^^^^^^^^^^^^^^^^^^^^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :constant

    sig { returns(YARP::Node) }
    attr_reader :left

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :requireds

    sig { returns(YARP::Node) }
    attr_reader :right

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(constant: T.nilable(YARP::Node), left: YARP::Node, requireds: T::Array[YARP::Node], right: YARP::Node, opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents a floating point number literal.
  #
  #     1.0
  #     ^^^
  class FloatNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `for` keyword.
  #
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    sig { returns(YARP::Node) }
    attr_reader :index

    sig { returns(YARP::Node) }
    attr_reader :collection

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :for_keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :in_keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :do_keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(index: YARP::Node, collection: YARP::Node, statements: T.nilable(YARP::Node), for_keyword_loc: YARP::Location, in_keyword_loc: YARP::Location, do_keyword_loc: T.nilable(Location), end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def for_keyword; end

    sig { returns(String) }
    def in_keyword; end

    sig { returns(T.nilable(String))}
    def do_keyword; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents forwarding all arguments to this method to another method.
  #
  #     def foo(...)
  #       bar(...)
  #       ^^^^^^^^
  #     end
  class ForwardingArgumentsNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  #
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `super` keyword without parentheses or arguments.
  #
  #     super
  #     ^^^^^
  class ForwardingSuperNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :block

    sig do
      params(block: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(block, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `&&=` operator for assignment to a global variable.
  #
  #     $target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorAndWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to a global variable.
  #
  #     $target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorOrWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a global variable using an operator that isn't `=`.
  #
  #     $target += value
  #     ^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, operator: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end
  end
  # Represents referencing a global variable.
  #
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to a global variable.
  #
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: T.nilable(Location), value: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents a hash literal.
  #
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :elements

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(opening_loc: YARP::Location, elements: T::Array[YARP::Node], closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(opening_loc, elements, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a hash pattern in pattern matching.
  #
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  #
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  class HashPatternNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :constant

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :assocs

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :kwrest

    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(constant: T.nilable(YARP::Node), assocs: T::Array[YARP::Node], kwrest: T.nilable(YARP::Node), opening_loc: T.nilable(Location), closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(constant, assocs, kwrest, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents the use of the `if` keyword, either in the block form or the modifier form.
  #
  #     bar if foo
  #     ^^^^^^^^^^
  #
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  class IfNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :if_keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :predicate

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :consequent

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig do
      params(if_keyword_loc: T.nilable(Location), predicate: YARP::Node, statements: T.nilable(YARP::Node), consequent: T.nilable(YARP::Node), end_keyword_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def if_keyword; end

    sig { returns(T.nilable(String))}
    def end_keyword; end
  end
  # Represents an imaginary number literal.
  #
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    sig { returns(YARP::Node) }
    attr_reader :numeric

    sig do
      params(numeric: YARP::Node, location: YARP::Location).void
    end
    def initialize(numeric, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `in` keyword in a case statement.
  #
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    sig { returns(YARP::Node) }
    attr_reader :pattern

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :in_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :then_loc

    sig do
      params(pattern: YARP::Node, statements: T.nilable(YARP::Node), in_loc: YARP::Location, then_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(pattern, statements, in_loc, then_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def in; end

    sig { returns(T.nilable(String))}
    def then; end
  end
  # Represents the use of the `&&=` operator for assignment to an instance variable.
  #
  #     @target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorAndWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to an instance variable.
  #
  #     @target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorOrWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to an instance variable using an operator that isn't `=`.
  #
  #     @target += value
  #     ^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :operator

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, operator: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, operator, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end
  end
  # Represents referencing an instance variable.
  #
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to an instance variable.
  #
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig do
      params(name_loc: YARP::Location, value: T.nilable(YARP::Node), operator_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(name_loc, value, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents an integer number literal.
  #
  #     1
  #     ^
  class IntegerNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a regular expression literal that contains interpolation.
  #
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :parts

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig do
      params(opening_loc: YARP::Location, parts: T::Array[YARP::Node], closing_loc: YARP::Location, flags: Integer, location: YARP::Location).void
    end
    def initialize(opening_loc, parts, closing_loc, flags, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a string literal that contains interpolation.
  #
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :parts

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(opening_loc: T.nilable(Location), parts: T::Array[YARP::Node], closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents a symbol literal that contains interpolation.
  #
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :parts

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig do
      params(opening_loc: T.nilable(Location), parts: T::Array[YARP::Node], closing_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents an xstring literal that contains interpolation.
  #
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :parts

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(opening_loc: YARP::Location, parts: T::Array[YARP::Node], closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(opening_loc, parts, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a hash literal without opening and closing braces.
  #
  #     foo(a: b)
  #         ^^^^
  class KeywordHashNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :elements

    sig do
      params(elements: T::Array[YARP::Node], location: YARP::Location).void
    end
    def initialize(elements, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b:)
  #           ^^
  #     end
  #
  #     def a(b: 1)
  #           ^^^^
  #     end
  class KeywordParameterNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig do
      params(name_loc: YARP::Location, value: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(name_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end
  end
  # Represents a keyword rest parameter to a method, block, or lambda definition.
  #
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig do
      params(operator_loc: YARP::Location, name_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(operator_loc, name_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(T.nilable(String))}
    def name; end
  end
  # Represents using a lambda literal (not the lambda method call).
  #
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :parameters

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig do
      params(locals: T::Array[YARP::Symbol], opening_loc: YARP::Location, parameters: T.nilable(YARP::Node), statements: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(locals, opening_loc, parameters, statements, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end
  end
  # Represents the use of the `&&=` operator for assignment to a local variable.
  #
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOperatorAndWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, constant_id: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, constant_id, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||=` operator for assignment to a local variable.
  #
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOperatorOrWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, constant_id: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, constant_id, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents assigning to a local variable using an operator that isn't `=`.
  #
  #     target += value
  #     ^^^^^^^^^^^^^^^
  class LocalVariableOperatorWriteNode < Node
    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig { returns(YARP::Symbol) }
    attr_reader :operator_id

    sig do
      params(name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, constant_id: YARP::Symbol, operator_id: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(name_loc, operator_loc, value, constant_id, operator_id, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents reading a local variable. Note that this requires that a local
  # variable of the same name has already been written to in the same scope,
  # otherwise it is parsed as a method call.
  #
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig { returns(Integer) }
    attr_reader :depth

    sig do
      params(constant_id: YARP::Symbol, depth: Integer, location: YARP::Location).void
    end
    def initialize(constant_id, depth, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents writing to a local variable.
  #
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig { returns(Integer) }
    attr_reader :depth

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig do
      params(constant_id: YARP::Symbol, depth: Integer, value: T.nilable(YARP::Node), name_loc: YARP::Location, operator_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(constant_id, depth, value, name_loc, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents the use of the modifier `in` operator.
  #
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Node) }
    attr_reader :pattern

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(value: YARP::Node, pattern: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(value, pattern, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `=>` operator.
  #
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    sig { returns(YARP::Node) }
    attr_reader :value

    sig { returns(YARP::Node) }
    attr_reader :pattern

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(value: YARP::Node, pattern: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(value, pattern, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents a node that is missing from the source and results in a syntax
  # error.
  class MissingNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a module declaration involving the `module` keyword.
  #
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Location) }
    attr_reader :module_keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :constant_path

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(locals: T::Array[YARP::Symbol], module_keyword_loc: YARP::Location, constant_path: YARP::Node, statements: T.nilable(YARP::Node), end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(locals, module_keyword_loc, constant_path, statements, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def module_keyword; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :targets

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :value

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig do
      params(targets: T::Array[YARP::Node], operator_loc: T.nilable(Location), value: T.nilable(YARP::Node), lparen_loc: T.nilable(Location), rparen_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(targets, operator_loc, value, lparen_loc, rparen_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def operator; end

    sig { returns(T.nilable(String))}
    def lparen; end

    sig { returns(T.nilable(String))}
    def rparen; end
  end
  # Represents the use of the `next` keyword.
  #
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(arguments: T.nilable(YARP::Node), keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(arguments, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents the use of the `nil` keyword.
  #
  #     nil
  #     ^^^
  class NilNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of `**nil` inside method arguments.
  #
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(operator_loc: YARP::Location, keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(operator_loc, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def keyword; end
  end
  # Represents reading a numbered reference to a capture in the previous match.
  #
  #     $1
  #     ^^
  class NumberedReferenceReadNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents an optional parameter to a method, block, or lambda definition.
  #
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig { returns(YARP::Location) }
    attr_reader :name_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :value

    sig do
      params(constant_id: YARP::Symbol, name_loc: YARP::Location, operator_loc: YARP::Location, value: YARP::Node, location: YARP::Location).void
    end
    def initialize(constant_id, name_loc, operator_loc, value, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def name; end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `||` operator or the `or` keyword.
  #
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    sig { returns(YARP::Node) }
    attr_reader :left

    sig { returns(YARP::Node) }
    attr_reader :right

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(left: YARP::Node, right: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(left, right, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the list of parameters on a method, block, or lambda definition.
  #
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :requireds

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :optionals

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :posts

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :rest

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :keywords

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :keyword_rest

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :block

    sig do
      params(requireds: T::Array[YARP::Node], optionals: T::Array[YARP::Node], posts: T::Array[YARP::Node], rest: T.nilable(YARP::Node), keywords: T::Array[YARP::Node], keyword_rest: T.nilable(YARP::Node), block: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(requireds, optionals, posts, rest, keywords, keyword_rest, block, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a parenthesized expression
  #
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(statements: T.nilable(YARP::Node), opening_loc: YARP::Location, closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(statements, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents the use of the `^` operator for pinning an expression in a
  # pattern matching expression.
  #
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    sig { returns(YARP::Node) }
    attr_reader :expression

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Location) }
    attr_reader :lparen_loc

    sig { returns(YARP::Location) }
    attr_reader :rparen_loc

    sig do
      params(expression: YARP::Node, operator_loc: YARP::Location, lparen_loc: YARP::Location, rparen_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def lparen; end

    sig { returns(String) }
    def rparen; end
  end
  # Represents the use of the `^` operator for pinning a variable in a pattern
  # matching expression.
  #
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    sig { returns(YARP::Node) }
    attr_reader :variable

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig do
      params(variable: YARP::Node, operator_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(variable, operator_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents the use of the `END` keyword.
  #
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(statements: T.nilable(YARP::Node), keyword_loc: YARP::Location, opening_loc: YARP::Location, closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents the use of the `BEGIN` keyword.
  #
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(statements: T.nilable(YARP::Node), keyword_loc: YARP::Location, opening_loc: YARP::Location, closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # The top level node of any parse tree.
  class ProgramNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Node) }
    attr_reader :statements

    sig do
      params(locals: T::Array[YARP::Symbol], statements: YARP::Node, location: YARP::Location).void
    end
    def initialize(locals, statements, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `..` or `...` operators.
  #
  #     1..2
  #     ^^^^
  #
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :left

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :right

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(Integer) }
    attr_reader :flags

    sig do
      params(left: T.nilable(YARP::Node), right: T.nilable(YARP::Node), operator_loc: YARP::Location, flags: Integer, location: YARP::Location).void
    end
    def initialize(left, right, operator_loc, flags, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents a rational number literal.
  #
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    sig { returns(YARP::Node) }
    attr_reader :numeric

    sig do
      params(numeric: YARP::Node, location: YARP::Location).void
    end
    def initialize(numeric, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `redo` keyword.
  #
  #     redo
  #     ^^^^
  class RedoNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a regular expression literal with no interpolation.
  #
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :content_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig { returns(Integer) }
    attr_reader :flags

    sig do
      params(opening_loc: YARP::Location, content_loc: YARP::Location, closing_loc: YARP::Location, unescaped: String, flags: Integer, location: YARP::Location).void
    end
    def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a destructured required parameter node.
  #
  #     def foo((bar, baz))
  #             ^^^^^^^^^^
  #     end
  class RequiredDestructuredParameterNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :parameters

    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig do
      params(parameters: T::Array[YARP::Node], opening_loc: YARP::Location, closing_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(parameters, opening_loc, closing_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def closing; end
  end
  # Represents a required parameter to a method, block, or lambda definition.
  #
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    sig { returns(YARP::Symbol) }
    attr_reader :constant_id

    sig do
      params(constant_id: YARP::Symbol, location: YARP::Location).void
    end
    def initialize(constant_id, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents an expression modified with a rescue.
  #
  #   foo rescue nil
  #   ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    sig { returns(YARP::Node) }
    attr_reader :expression

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :rescue_expression

    sig do
      params(expression: YARP::Node, keyword_loc: YARP::Location, rescue_expression: YARP::Node, location: YARP::Location).void
    end
    def initialize(expression, keyword_loc, rescue_expression, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents a rescue statement.
  #
  #     begin
  #     rescue Foo, *splat, Bar => ex
  #     ^^^^^^
  #       foo
  #     end
  #
  # `Foo, *splat, Bar` are in the `exceptions` field.
  # `ex` is in the `exception` field.
  class RescueNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :exceptions

    sig { returns(T.nilable(Location)) }
    attr_reader :operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :reference

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :consequent

    sig do
      params(keyword_loc: YARP::Location, exceptions: T::Array[YARP::Node], operator_loc: T.nilable(Location), reference: T.nilable(YARP::Node), statements: T.nilable(YARP::Node), consequent: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String))}
    def operator; end
  end
  # Represents a rest parameter to a method, block, or lambda definition.
  #
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :name_loc

    sig do
      params(operator_loc: YARP::Location, name_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(operator_loc, name_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end

    sig { returns(T.nilable(String))}
    def name; end
  end
  # Represents the use of the `retry` keyword.
  #
  #     retry
  #     ^^^^^
  class RetryNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `return` keyword.
  #
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig do
      params(keyword_loc: YARP::Location, arguments: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(keyword_loc, arguments, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents the `self` keyword.
  #
  #     self
  #     ^^^^
  class SelfNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a singleton class declaration involving the `class` keyword.
  #
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    sig { returns(T::Array[YARP::Symbol]) }
    attr_reader :locals

    sig { returns(YARP::Location) }
    attr_reader :class_keyword_loc

    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(YARP::Node) }
    attr_reader :expression

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(YARP::Location) }
    attr_reader :end_keyword_loc

    sig do
      params(locals: T::Array[YARP::Symbol], class_keyword_loc: YARP::Location, operator_loc: YARP::Location, expression: YARP::Node, statements: T.nilable(YARP::Node), end_keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(locals, class_keyword_loc, operator_loc, expression, statements, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def class_keyword; end

    sig { returns(String) }
    def operator; end

    sig { returns(String) }
    def end_keyword; end
  end
  # Represents the use of the `__ENCODING__` keyword.
  #
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `__FILE__` keyword.
  #
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    sig { returns(String) }
    attr_reader :filepath

    sig do
      params(filepath: String, location: YARP::Location).void
    end
    def initialize(filepath, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `__LINE__` keyword.
  #
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the splat operator.
  #
  #     [*a]
  #      ^^
  class SplatNode < Node
    sig { returns(YARP::Location) }
    attr_reader :operator_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :expression

    sig do
      params(operator_loc: YARP::Location, expression: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(operator_loc, expression, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def operator; end
  end
  # Represents a set of statements contained within some scope.
  #
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :body

    sig do
      params(body: T::Array[YARP::Node], location: YARP::Location).void
    end
    def initialize(body, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of compile-time string concatenation.
  #
  #     "foo" "bar"
  #     ^^^^^^^^^^^
  class StringConcatNode < Node
    sig { returns(YARP::Node) }
    attr_reader :left

    sig { returns(YARP::Node) }
    attr_reader :right

    sig do
      params(left: YARP::Node, right: YARP::Node, location: YARP::Location).void
    end
    def initialize(left, right, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents a string literal, a string contained within a `%w` list, or
  # plain string content within an interpolated string.
  #
  #     "foo"
  #     ^^^^^
  #
  #     %w[foo]
  #        ^^^
  #
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :content_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig do
      params(opening_loc: T.nilable(Location), content_loc: YARP::Location, closing_loc: T.nilable(Location), unescaped: String, location: YARP::Location).void
    end
    def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents the use of the `super` keyword with parentheses or arguments.
  #
  #     super()
  #     ^^^^^^^
  #
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  class SuperNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :block

    sig do
      params(keyword_loc: YARP::Location, lparen_loc: T.nilable(Location), arguments: T.nilable(YARP::Node), rparen_loc: T.nilable(Location), block: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(
        T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location]
      )])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String))}
    def lparen; end

    sig { returns(T.nilable(String))}
    def rparen; end
  end
  # Represents a symbol literal or a symbol contained within a `%i` list.
  #
  #     :foo
  #     ^^^^
  #
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    sig { returns(T.nilable(Location)) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :value_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig do
      params(opening_loc: T.nilable(Location), value_loc: YARP::Location, closing_loc: T.nilable(Location), unescaped: String, location: YARP::Location).void
    end
    def initialize(opening_loc, value_loc, closing_loc, unescaped, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(T.nilable(String))}
    def opening; end

    sig { returns(String) }
    def value; end

    sig { returns(T.nilable(String))}
    def closing; end
  end
  # Represents the use of the literal `true` keyword.
  #
  #     true
  #     ^^^^
  class TrueNode < Node
    sig do
      params(location: YARP::Location).void
    end
    def initialize(location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end
  end
  # Represents the use of the `undef` keyword.
  #
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    sig { returns(T::Array[YARP::Node]) }
    attr_reader :names

    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig do
      params(names: T::Array[YARP::Node], keyword_loc: YARP::Location, location: YARP::Location).void
    end
    def initialize(names, keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  #
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  #
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :predicate

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :consequent

    sig { returns(T.nilable(Location)) }
    attr_reader :end_keyword_loc

    sig do
      params(keyword_loc: YARP::Location, predicate: YARP::Node, statements: T.nilable(YARP::Node), consequent: T.nilable(YARP::Node), end_keyword_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String))}
    def end_keyword; end
  end
  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  #
  #     bar until foo
  #     ^^^^^^^^^^^^^
  #
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :predicate

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(Integer) }
    attr_reader :flags

    sig do
      params(keyword_loc: YARP::Location, predicate: YARP::Node, statements: T.nilable(YARP::Node), flags: Integer, location: YARP::Location).void
    end
    def initialize(keyword_loc, predicate, statements, flags, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # case true
  # when true
  # ^^^^^^^^^
  # end
  class WhenNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(T::Array[YARP::Node]) }
    attr_reader :conditions

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig do
      params(keyword_loc: YARP::Location, conditions: T::Array[YARP::Node], statements: T.nilable(YARP::Node), location: YARP::Location).void
    end
    def initialize(keyword_loc, conditions, statements, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  #
  #     bar while foo
  #     ^^^^^^^^^^^^^
  #
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(YARP::Node) }
    attr_reader :predicate

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :statements

    sig { returns(Integer) }
    attr_reader :flags

    sig do
      params(keyword_loc: YARP::Location, predicate: YARP::Node, statements: T.nilable(YARP::Node), flags: Integer, location: YARP::Location).void
    end
    def initialize(keyword_loc, predicate, statements, flags, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end
  end
  # Represents an xstring literal with no interpolation.
  #
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    sig { returns(YARP::Location) }
    attr_reader :opening_loc

    sig { returns(YARP::Location) }
    attr_reader :content_loc

    sig { returns(YARP::Location) }
    attr_reader :closing_loc

    sig { returns(String) }
    attr_reader :unescaped

    sig do
      params(opening_loc: YARP::Location, content_loc: YARP::Location, closing_loc: YARP::Location, unescaped: String, location: YARP::Location).void
    end
    def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def opening; end

    sig { returns(String) }
    def content; end

    sig { returns(String) }
    def closing; end
  end
  # Represents the use of the `yield` keyword.
  #
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    sig { returns(YARP::Location) }
    attr_reader :keyword_loc

    sig { returns(T.nilable(Location)) }
    attr_reader :lparen_loc

    sig { returns(T.nilable(YARP::Node)) }
    attr_reader :arguments

    sig { returns(T.nilable(Location)) }
    attr_reader :rparen_loc

    sig do
      params(keyword_loc: YARP::Location, lparen_loc: T.nilable(Location), arguments: T.nilable(YARP::Node), rparen_loc: T.nilable(Location), location: YARP::Location).void
    end
    def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

    sig { params(visitor: YARP::Visitor).void }
    def accept(visitor); end

    sig { params(newline_marked: T::Boolean).void }
    def set_newline_flag(newline_marked); end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    def child_nodes; end

    sig { returns T::Array[T.nilable(YARP::Node)] }
    alias deconstruct child_nodes

    sig do
      params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.any(nil, YARP::Node, T::Array[YARP::Node], String, YARP::Token, T::Array[YARP::Token], YARP::Location])])
    end
    def deconstruct_keys(keys); end

    sig { returns(String) }
    def keyword; end

    sig { returns(T.nilable(String))}
    def lparen; end

    sig { returns(T.nilable(String))}
    def rparen; end
  end
end
